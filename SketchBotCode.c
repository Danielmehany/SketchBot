#pragma config(Motor, port2, leftMotor, tmotorVex393_HBridge, openLoop)
#pragma config(Motor, port3, rightMotor, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard  

// File: C:\Users\dmehany\Desktop\SketchBot.c

// File input/output library
#include "PC_FileIO.c"

// Conversion factors based on radius of wheels
const float conversionX = (2 * PI * 1.75) / 360;
const float conversionY = (2 * PI * 2.75) / 360;

// File input
void file(int &length, int &width, int &Xsep, int &Ysep) {
    TFileHandle fin;
    bool fileOkay = openReadPC(fin, "Dimensions.txt");

    if (!fileOkay) {
        displayTextLine(1, "File open failed");
        wait1Msec(10000);
        return;
    }

    if (readIntPC(fin, length)) {
        displayTextLine(1, "Length: %d", length);
    } else {
        displayTextLine(1, "Error reading length");
        wait1Msec(1000);
        return;
    }

    if (readIntPC(fin, width)) {
        displayTextLine(2, "Width: %d", width);
    } else {
        displayTextLine(2, "Error reading width");
        wait1Msec(1000);
        return;
    }

    if (readIntPC(fin, Ysep)) {
        displayTextLine(3, "Ysep: %d", Ysep);
    } else {
        displayTextLine(3, "Error reading Ysep");
        wait1Msec(1000);
        return;
    }

    if (readIntPC(fin, Xsep)) {
        displayTextLine(4, "Xsep: %d", Xsep);
    } else {
        displayTextLine(4, "Error reading Xsep");
        wait1Msec(1000);
        return;
    }
}

// Moves robot forward along the X axis
void Xaxis(float &distanceTraveledX, int width) {
    nMotorEncoder[motorC] = 0;
    motor[motorC] = 10;
    while (abs(nMotorEncoder[motorC] * conversionX) < width) {}
    distanceTraveledX += width;
    motor[motorC] = 0;
}

// Moves robot backwards along the X axis
void XRaxis(float &distanceTraveledX, int width) {
    nMotorEncoder[motorC] = 0;
    motor[motorC] = -10;
    while (abs(nMotorEncoder[motorC] * conversionX) < width) {}
    distanceTraveledX += width;
    motor[motorC] = 0;
}

// Moves robot forward along the Y axis
void Yaxis(float &distanceTraveledY, int length) {
    nMotorEncoder[motorA] = 0;
    motor[motorA] = motor[motorB] = 10;
    while (abs(nMotorEncoder[motorA] * conversionY) < length) {}
    distanceTraveledY += length;
    motor[motorA] = motor[motorB] = 0;
}

// Moves robot backwards along the Y axis
void YRaxis(float &distanceTraveledY, int length) {
    nMotorEncoder[motorA] = 0;
    motor[motorA] = motor[motorB] = -10;
    while (abs(nMotorEncoder[motorA] * conversionY) < length) {}
    distanceTraveledY += length;
    motor[motorA] = motor[motorB] = 0;
}

// Returns robot to start
void returnToStart(float distanceTraveledX, float distanceTraveledY, int numOfSq) {
    if (numOfSq > 1) {
        nMotorEncoder[motorB] = nMotorEncoder[motorC] = 0;
        displayTextLine(5, "Returning to start...");
        motor[motorA] = motor[motorB] = -10;
        while (abs(nMotorEncoder[motorB] * conversionY) < distanceTraveledY) {}
        motor[motorC] = -10;
        while (abs(nMotorEncoder[motorC] * conversionX) < distanceTraveledX) {}
        displayTextLine(6, "Return complete!");
    }
}

// Draws a singular square/rectangle
void draw(float &distanceTraveledX, float &distanceTraveledY, int width, int length) {
    SensorType[S1] = sensorEV3_Touch;
    if (SensorValue[S1] == 0) {
        displayTextLine(5, "Starting draw()");
        Xaxis(distanceTraveledX, width);
        Yaxis(distanceTraveledY, length);
    }
    SensorType[S1] = sensorEV3_Touch;
    if (SensorValue[S1] == 0) {
        XRaxis(distanceTraveledX, width);
        YRaxis(distanceTraveledY, length);
    }
}

// Moves robot along the X and Y axis by indicated separation distance
void separation(int Xsep, int Ysep) {
    SensorType[S1] = sensorEV3_Touch;
    if (SensorValue[S1] == 0) {
        nMotorEncoder[motorC] = 0;
        motor[motorC] = 10;
        while (abs(nMotorEncoder[motorC] * conversionX) < Xsep) {}
        motor[motorC] = 0;

        nMotorEncoder[motorA] = 0;
        motor[motorA] = motor[motorB] = 10;
        while (abs(nMotorEncoder[motorA] * conversionY) < Ysep) {}
        motor[motorA] = motor[motorB] = 0;
    }
}

// Raises drawing arm
void raise() {
    SensorType[S1] = sensorEV3_Touch;
    if (SensorValue[S1] == 0) {
        nMotorEncoder[motorD] = 0;
        motor[motorD] = 25;
        while (abs(nMotorEncoder[motorD]) < 25) {}
        motor[motorD] = 0;
    }
}

// Lowers drawing arm
void lower() {
    SensorType[S1] = sensorEV3_Touch;
    if (SensorValue[S1] == 0) {
        nMotorEncoder[motorD] = 0;
        motor[motorD] = -25;
        while (abs(nMotorEncoder[motorD]) < 30) {}
        motor[motorD] = 0;
    }
}

// Takes user input to determine the number of squares
int buttonPress() {
    displayTextLine(5, "Press a button to select squares.");
    while (!getButtonPress(buttonAny)) {}

    if (getButtonPress(buttonUp)) {
        displayTextLine(6, "Selected: 1 square");
        return 1;
    } else if (getButtonPress(buttonRight)) {
        displayTextLine(6, "Selected: 2 squares");
        return 2;
    } else if (getButtonPress(buttonDown)) {
        displayTextLine(6, "Selected: 3 squares");
        return 3;
    } else if (getButtonPress(buttonLeft)) {
        displayTextLine(6, "Selected: 4 squares");
        return 4;
    }

    return 0;
}

// Main task
task main() {
    displayTextLine(1, "Starting program...");
    wait1Msec(1000);

    int length, width, Xsep, Ysep;
    file(length, width, Xsep, Ysep);

    int numOfSq = buttonPress();
    displayTextLine(7, "Squares to draw: %d", numOfSq);
    wait1Msec(2000);

    float distanceTraveledX = 0.0;
    float distanceTraveledY = 0.0;

    // Starts timer
    time1[T1] = 0;

    for (int i = 0; i < numOfSq; i++) {
        SensorType[S1] = sensorEV3_Touch;
        displayTextLine(8, "Drawing square %d of %d", i + 1, numOfSq);
        draw(distanceTraveledX, distanceTraveledY, width, length);
        wait1Msec(1000);
        raise();

        if (i < (numOfSq - 1)) {
            separation(Xsep, Ysep);
            lower();
            wait1Msec(1000);
        }
    }

    float end_time = time1[T1]; // Ends timer
    displayTextLine(10, "Drawing complete!");
    displayTextLine(11, "Total Time: ");
    displayTextLine(12, "%.2f", (end_time / 1000));
    wait1Msec(3000);

    returnToStart(distanceTraveledX, distanceTraveledY, numOfSq);
}